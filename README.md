# üéÆ Fullstack RPG - Tutorial Completo para Principiantes

Un proyecto de juego multijugador en tiempo real desarrollado con **Phaser 3** (cliente) y **Colyseus** (servidor). Este proyecto te permitir√° aprender los fundamentos del desarrollo de juegos web y sistemas multijugador.

## üìñ ¬øQu√© es este proyecto?

Este es un **juego RPG multijugador** donde los jugadores pueden moverse en tiempo real y ver a otros jugadores conectados. Implementa:

- ‚úÖ **Sistema de escenas** con flujo de juego completo
- ‚úÖ **Multijugador en tiempo real** con sincronizaci√≥n de estados
- ‚úÖ **Predicci√≥n del lado del cliente** para movimiento fluido
- ‚úÖ **Interpolaci√≥n** de posiciones de otros jugadores
- ‚úÖ **Sistema de ticks fijos** para consistencia en el servidor
- ‚úÖ **Usernames personalizados** que aparecen arriba de cada jugador
- ‚úÖ **Selecci√≥n aleatoria de naves** de 23 dise√±os disponibles
- ‚úÖ **Doble sistema de controles** - Flechas del teclado y teclas WASD
- ‚úÖ **Soporte masivo** para hasta 100 jugadores simult√°neos

## üöÄ Instalaci√≥n R√°pida

### Prerrequisitos

- Node.js 16+ instalado
- Un editor de c√≥digo (VS Code recomendado)

### Configuraci√≥n del Proyecto

1. **Clona o descarga el proyecto**
2. **Instalar dependencias del backend:**

   ```bash
   cd backend
   npm install
   ```

3. **Instalar dependencias del frontend:**
   ```bash
   cd ../frontend
   npm install
   ```

### Ejecutar el Proyecto

1. **Iniciar el servidor (backend):**

   ```bash
   cd backend
   npm run dev
   ```

   ‚úÖ El servidor estar√° en `http://localhost:2567`

2. **Iniciar el cliente (frontend):**

   ```bash
   cd frontend
   npm run dev
   ```

   ‚úÖ El juego estar√° en `http://localhost:8080`

3. **¬°Jugar!**
   - Abre m√∫ltiples pesta√±as del navegador para ver el multijugador
   - **Se te pedir√° un nombre de usuario** al entrar al juego
   - **Se te asignar√° una nave aleatoria** de las 23 disponibles
   - **Controles disponibles:**
     - **Flechas del teclado**: ‚Üë ‚Üì ‚Üê ‚Üí para moverse
     - **Teclas WASD**: W (arriba), A (izquierda), S (abajo), D (derecha)
   - **Hasta 100 jugadores** pueden jugar simult√°neamente
   - ¬°Ver√°s tu nombre y el de otros jugadores arriba de las naves!

## üéØ ¬øQu√© es Phaser 3?

**Phaser** es un framework de JavaScript para crear juegos 2D que funcionan en navegadores web. Es como el "motor" que maneja gr√°ficos, sonido, f√≠sica y entrada del usuario.

### Conceptos Fundamentales de Phaser

#### 1. El Game Object (Objeto Juego)

```typescript
// frontend/src/game/root.ts - Configuraci√≥n principal
const config: Phaser.Types.Core.GameConfig = {
  type: AUTO, // Usa WebGL o Canvas autom√°ticamente
  width: 800, // Ancho del juego en p√≠xeles
  height: 600, // Alto del juego en p√≠xeles
  parent: "game-container", // Elemento HTML donde se renderiza
  backgroundColor: "#028af8", // Color de fondo
  physics: {
    default: "arcade", // Sistema de f√≠sica arcade (simple)
  },
  pixelArt: true, // Optimizado para gr√°ficos pixelados
  scene: [Boot, Preloader, MainMenu, MainGame, GameOver], // Lista de escenas
};
```

#### 2. Escenas (Scenes) - Los "Estados" del Juego

Las escenas son como diferentes pantallas o estados de tu juego:

##### üîß Boot Scene (`frontend/src/game/scenes/Boot.ts`)

**Prop√≥sito:** Primera escena que se ejecuta, carga recursos m√≠nimos

```typescript
export class Boot extends Scene {
  preload() {
    // Carga solo recursos esenciales (fondos, logos)
    this.load.image("background", "assets/bg.png");
  }

  create() {
    // Inmediatamente cambia a Preloader
    this.scene.start("Preloader");
  }
}
```

##### ‚è≥ Preloader Scene (`frontend/src/game/scenes/Preloader.ts`)

**Prop√≥sito:** Muestra progreso de carga y carga todos los assets del juego

```typescript
export class Preloader extends Scene {
  init() {
    // Muestra fondo y crea barra de progreso visual
    this.add.image(512, 384, "background");
    const bar = this.add.rectangle(512 - 230, 384, 4, 28, 0xffffff);

    // Actualiza barra cuando cargan assets
    this.load.on("progress", (progress: number) => {
      bar.width = 4 + 460 * progress;
    });
  }

  preload() {
    // Carga todos los assets del juego
    this.load.image("logo", "logo.png");
    this.load.image("ship_0001", "ship_0001.png");
  }
}
```

##### üéÆ Main Menu Scene (`frontend/src/game/scenes/MainMenu.ts`)

**Prop√≥sito:** Men√∫ principal con logo y texto

```typescript
export class MainMenu extends Scene {
  create() {
    // Muestra logo y t√≠tulo
    this.add.image(512, 300, "logo");
    this.add
      .text(512, 460, "Main Menu", {
        fontFamily: "Arial Black",
        fontSize: 38,
        color: "#ffffff",
      })
      .setOrigin(0.5);

    // Al hacer clic, inicia el juego
    this.input.once("pointerdown", () => {
      this.scene.start("Game");
    });
  }
}
```

##### üéØ Game Scene (`frontend/src/game/scenes/Game.ts`) - ¬°El Coraz√≥n!

**Prop√≥sito:** Escena principal donde ocurre toda la jugabilidad multijugador

**M√©todos Principales:**

```typescript
export class Game extends Scene {
  async create() {
    // 1. Configurar controles
    this.cursorKeys = this.input.keyboard.createCursorKeys();

    // 2. Conectar al servidor Colyseus
    await this.connect();

    // 3. Configurar callbacks para jugadores
    this.room.state.players.onAdd((player, sessionId) => {
      // Crear sprite cuando un jugador se une
      const entity = this.physics.add.image(player.x, player.y, "ship_0001");
      this.playerEntities[sessionId] = entity;
    });
  }

  update(time: number, delta: number) {
    // Se ejecuta cada frame (60 veces por segundo)
    // Maneja el loop de juego con tiempo fijo
    this.elapsedTime += delta;
    while (this.elapsedTime >= this.fixedTimeStep) {
      this.elapsedTime -= this.fixedTimeStep;
      this.fixedTick(time, this.fixedTimeStep);
    }
  }

  fixedTick() {
    // Procesa entrada del usuario
    // Mueve jugador localmente (predicci√≥n)
    // Env√≠a input al servidor
    // Interpola otros jugadores
  }
}
```

## üåê ¬øQu√© es Colyseus?

**Colyseus** es un framework de servidor para crear juegos multijugador en tiempo real. Maneja la comunicaci√≥n entre m√∫ltiples clientes y sincroniza el estado del juego.

### Arquitectura del Servidor

#### 1. Punto de Entrada (`backend/src/index.ts`)

```typescript
// Importa configuraci√≥n y inicia servidor
import { listen } from "@colyseus/tools";
import app from "./app.config";

listen(app); // Escucha en puerto 2567
```

#### 2. Configuraci√≥n del Servidor (`backend/src/app.config.ts`)

```typescript
export default config({
  initializeGameServer: (gameServer) => {
    // Registra tipos de salas disponibles
    gameServer.define("my_room", MyRoom);
  },

  initializeExpress: (app) => {
    // Configura rutas HTTP adicionales
    app.get("/hello_world", (req, res) => {
      res.send("It's time to kick ass and chew bubblegum!");
    });

    // Panel de monitoreo en /monitor
    app.use("/monitor", monitor());
  },
});
```

#### 3. La Sala de Juego (`backend/src/rooms/MyRoom.ts`) - ¬°El Cerebro!

Una **Room** es donde ocurre toda la l√≥gica del juego multijugador:

```typescript
export class MyRoom extends Room<MyRoomState> {
  maxClients = 4; // M√°ximo 4 jugadores por sala
  fixedTimeStep = 1000 / 60; // 60 ticks por segundo

  onCreate(options: any) {
    // Configuraci√≥n inicial
    this.state.mapWidth = 800;
    this.state.mapHeight = 600;

    // Escucha mensajes del cliente (mensaje tipo 0 = movimiento)
    this.onMessage(0, (client, input) => {
      const player = this.state.players.get(client.sessionId);
      player.inputQueue.push(input); // Agrega a cola de entrada
    });

    // Simulaci√≥n de servidor a ticks fijos
    this.setSimulationInterval((deltaTime) => {
      // Procesa todos los inputs pendientes
      this.fixedTick(this.fixedTimeStep);
    });
  }

  fixedTick(timeStep: number) {
    const velocity = 2;

    this.state.players.forEach((player) => {
      let input: InputData;

      // Procesa todos los inputs en cola
      while ((input = player.inputQueue.shift())) {
        if (input.left) player.x -= velocity;
        if (input.right) player.x += velocity;
        if (input.up) player.y -= velocity;
        if (input.down) player.y += velocity;

        player.tick = input.tick; // Sincroniza tick
      }
    });
  }

  onJoin(client: Client, options: any) {
    // Se ejecuta cuando un jugador se conecta
    const player = new Player();
    player.x = Math.random() * this.state.mapWidth; // Posici√≥n aleatoria
    player.y = Math.random() * this.state.mapHeight;

    this.state.players.set(client.sessionId, player);
  }

  onLeave(client: Client, consented: boolean) {
    // Se ejecuta cuando un jugador se desconecta
    this.state.players.delete(client.sessionId);
  }
}
```

#### 4. Estado del Juego (`backend/src/rooms/schema/MyRoomState.ts`)

El **Estado** es lo que se sincroniza entre servidor y todos los clientes:

```typescript
export class Player extends Schema {
  @type("number") x: number; // Posici√≥n X
  @type("number") y: number; // Posici√≥n Y
  @type("number") tick: number; // Tick actual para sincronizaci√≥n
  inputQueue: InputData[] = []; // Cola de inputs (no se sincroniza)
}

export class MyRoomState extends Schema {
  @type("number") mapWidth: number; // Ancho del mapa
  @type("number") mapHeight: number; // Alto del mapa
  @type({ map: Player }) players = new MapSchema<Player>(); // Todos los jugadores
}

export interface InputData {
  left: boolean; // ¬øPresionando izquierda?
  right: boolean; // ¬øPresionando derecha?
  up: boolean; // ¬øPresionando arriba?
  down: boolean; // ¬øPresionando abajo?
  tick: number; // Tick del cliente cuando envi√≥ input
}
```

## üîÑ Flujo de Comunicaci√≥n Cliente-Servidor

### 1. **Inicializaci√≥n**

```mermaid
sequenceDiagram
    participant C as Cliente
    participant S as Servidor
    C->>S: Conectar a ws://localhost:2567
    C->>S: Unirse a sala "my_room"
    S->>C: Env√≠a estado inicial (otros jugadores)
```

### 2. **Loop de Juego (cada frame)**

```mermaid
sequenceDiagram
    participant C as Cliente
    participant S as Servidor
    participant T as Todos los Clientes
    Note over C: Lee teclas presionadas
    Note over C: Mueve jugador localmente (PREDICCI√ìN)
    C->>S: Env√≠a input {left: true, tick: 1234}
    Note over S: Procesa input, actualiza posici√≥n oficial
    S->>T: Sincroniza nuevo estado
    Note over C: Compara posici√≥n local vs servidor (RECONCILIACI√ìN)
```

### 3. **Otros Jugadores**

```mermaid
sequenceDiagram
    participant S as Servidor
    participant C as Cliente
    S->>C: Estado de otros jugadores actualizado
    Note over C: INTERPOLA posiciones suavemente
    Note over C: Renderiza frame con todos los jugadores
```

## üõ†Ô∏è T√©cnicas Avanzadas Implementadas

### 1. **Predicci√≥n del Lado del Cliente**

```typescript
// En Game.ts - fixedTick()
// El cliente mueve al jugador INMEDIATAMENTE
if (this.inputPayload.left) {
  this.currentPlayer.x -= velocity; // ‚ö° Respuesta inmediata
}
// Luego env√≠a el input al servidor
this.room.send(0, this.inputPayload);
```

### 2. **Interpolaci√≥n de Otros Jugadores**

```typescript
// En Game.ts - fixedTick()
for (let sessionId in this.playerEntities) {
  if (sessionId === this.room.sessionId) continue; // Saltar jugador local

  const entity = this.playerEntities[sessionId];
  const { serverX, serverY } = entity.data.values;

  // Mueve suavemente hacia la posici√≥n del servidor
  entity.x = Phaser.Math.Linear(entity.x, serverX, 0.2); // üåä Interpolaci√≥n suave
  entity.y = Phaser.Math.Linear(entity.y, serverY, 0.2);
}
```

### 3. **Sistema de Ticks Fijos**

```typescript
// Tanto cliente como servidor usan tiempo fijo
const fixedTimeStep = 1000 / 60; // 60 FPS

update(time: number, delta: number) {
  this.elapsedTime += delta;
  while (this.elapsedTime >= this.fixedTimeStep) {
    this.elapsedTime -= this.fixedTimeStep;
    this.fixedTick(); // ‚è∞ L√≥gica a tiempo fijo
  }
}
```

## ‚è∞ ¬øQu√© son los Ticks? - Explicaci√≥n para Principiantes

Los **ticks** son uno de los conceptos m√°s importantes en el desarrollo de juegos multijugador. Te explico de forma sencilla:

### üéØ ¬øQu√© es un Tick?

Un **tick** es como el "latido del coraz√≥n" del juego. Es una unidad de tiempo fija en la que el servidor (y cliente) actualizan la l√≥gica del juego.

#### Analog√≠a Simple

Imag√≠nate que el juego es como una pel√≠cula:

- Una **pel√≠cula** tiene 24 fotogramas por segundo
- Un **juego** tiene 60 **ticks** por segundo

En cada tick, el servidor:

1. ‚úÖ Procesa los inputs de todos los jugadores
2. ‚úÖ Actualiza posiciones de personajes
3. ‚úÖ Calcula colisiones
4. ‚úÖ Env√≠a el estado actualizado a todos los clientes

### üïê Tiempo Fijo vs Tiempo Variable

#### ‚ùå Problema sin Ticks Fijos

```typescript
// MAL: Basado en tiempo real (variable)
update(deltaTime) {
    player.x += speed * deltaTime; // ¬°Inconsistente!
}
```

**Problema:** Si el juego va lento, el jugador se mueve menos. Si va r√°pido, se mueve m√°s.

#### ‚úÖ Soluci√≥n con Ticks Fijos

```typescript
// BIEN: Tiempo fijo
const TICK_RATE = 1000 / 60; // 60 ticks por segundo = 16.67ms por tick

fixedTick() {
    player.x += speed; // ¬°Siempre la misma velocidad!
}
```

### üîÑ C√≥mo Funcionan en tu Proyecto

#### En el Servidor (`MyRoom.ts`)

```typescript
export class MyRoom extends Room<MyRoomState> {
  fixedTimeStep = 1000 / 60; // 60 ticks por segundo

  onCreate() {
    // Configura el tick fijo del servidor
    this.setSimulationInterval((deltaTime) => {
      this.fixedTick(this.fixedTimeStep);
    });
  }

  fixedTick(timeStep: number) {
    // Procesa TODOS los inputs pendientes
    this.state.players.forEach((player) => {
      let input: InputData;

      while ((input = player.inputQueue.shift())) {
        if (input.left) player.x -= 2;
        if (input.right) player.x += 2;

        player.tick = input.tick; // ‚≠ê Sincroniza el n√∫mero de tick
      }
    });
  }
}
```

#### En el Cliente (`Game.ts`)

```typescript
export class Game extends Scene {
  private elapsedTime = 0;
  private fixedTimeStep = 1000 / 60; // Mismo tick rate que servidor
  private currentTick = 0;

  update(time: number, delta: number) {
    this.elapsedTime += delta;

    // Ejecuta ticks fijos aunque el framerate sea variable
    while (this.elapsedTime >= this.fixedTimeStep) {
      this.elapsedTime -= this.fixedTimeStep;
      this.currentTick++; // ‚≠ê Incrementa contador de tick
      this.fixedTick();
    }
  }

  fixedTick() {
    // Lee input y lo marca con el tick actual
    this.inputPayload = {
      left: this.cursorKeys.left.isDown,
      right: this.cursorKeys.right.isDown,
      tick: this.currentTick, // ‚≠ê N√∫mero de tick cuando se envi√≥
    };

    // Env√≠a al servidor
    this.room.send(0, this.inputPayload);
  }
}
```

### üé≠ Los Ticks Resuelven Problemas Importantes

#### 1. **Sincronizaci√≥n**

```typescript
// El cliente env√≠a: { left: true, tick: 1205 }
// El servidor procesa exactamente en el tick 1205
// ‚úÖ Todos los jugadores ven lo mismo al mismo tiempo
```

#### 2. **Predicci√≥n del Cliente**

```typescript
// Cliente predice inmediatamente
if (input.left) {
  this.currentPlayer.x -= 2; // ‚ö° Respuesta instant√°nea
}

// Servidor confirma m√°s tarde
// Si hay diferencia, el cliente se corrige suavemente
```

#### 3. **Reconciliaci√≥n**

```typescript
// Cliente compara su predicci√≥n vs respuesta del servidor
if (Math.abs(localPlayer.x - serverPlayer.x) > 5) {
  // Ajustar posici√≥n gradualmente
  localPlayer.x = Phaser.Math.Linear(localPlayer.x, serverPlayer.x, 0.1);
}
```

### üìä Ejemplo Visual de Ticks

```
Tick 1200: Jugador en X=100, presiona ‚Üí
Tick 1201: Jugador en X=102, presiona ‚Üí
Tick 1202: Jugador en X=104, presiona ‚Üí
Tick 1203: Jugador en X=106, suelta ‚Üí
Tick 1204: Jugador en X=106, sin input
```

### ‚öôÔ∏è Configuraciones Comunes

#### Tick Rates T√≠picos

```typescript
// Juegos de acci√≥n r√°pida (shooters)
const TICK_RATE = 1000 / 128; // 128 ticks/segundo

// Juegos normales (la mayor√≠a)
const TICK_RATE = 1000 / 60; // 60 ticks/segundo

// Juegos m√°s lentos (estrategia)
const TICK_RATE = 1000 / 20; // 20 ticks/segundo
```

#### En tu `MyRoomState.ts`

```typescript
export interface InputData {
  left: boolean;
  right: boolean;
  up: boolean;
  down: boolean;
  tick: number; // ‚≠ê El n√∫mero de tick es CRUCIAL
}

export class Player extends Schema {
  @type("number") x: number;
  @type("number") y: number;
  @type("number") tick: number; // ‚≠ê √öltimo tick procesado del jugador

  inputQueue: InputData[] = []; // Cola de inputs pendientes
}
```

### üöÄ ¬øPor Qu√© es Tan Importante?

#### Sin Ticks Fijos:

- ‚ùå Jugadores con mejor computadora se mueven m√°s r√°pido
- ‚ùå Lag hace que el juego se vuelva impredecible
- ‚ùå Imposible sincronizar m√∫ltiples jugadores
- ‚ùå Cheating m√°s f√°cil

#### Con Ticks Fijos:

- ‚úÖ Todos los jugadores van a la misma velocidad
- ‚úÖ El juego es determin√≠stico y reproducible
- ‚úÖ Sincronizaci√≥n perfecta entre clientes
- ‚úÖ Detecci√≥n de cheating m√°s f√°cil

### üí° Tips para Principiantes

1. **Tick = Paso de tiempo fijo** (ej: cada 16.67ms)
2. **N√∫mero de tick = Contador** que se incrementa cada paso
3. **Input con tick** permite saber "cu√°ndo" se presion√≥ una tecla
4. **Servidor autoritativo** usa ticks para validar todo
5. **Cliente predice** pero servidor tiene la palabra final

¬°Los ticks son la base de todo juego multijugador serio! üéÆ‚ú®

## üéì Tutorial: Crear tu Primera Funci√≥n

### Ejemplo 1: Agregar Sistema de Chat

**1. A√±adir al estado (Backend):**

```typescript
// MyRoomState.ts
export class ChatMessage extends Schema {
  @type("string") text: string;
  @type("string") author: string;
}

export class MyRoomState extends Schema {
  // ... c√≥digo existente ...
  @type([ChatMessage]) messages = new ArraySchema<ChatMessage>();
}
```

**2. Manejar mensajes (Backend):**

```typescript
// MyRoom.ts - dentro de onCreate()
this.onMessage("chat", (client, data) => {
  const message = new ChatMessage();
  message.text = data.text;
  message.author = client.sessionId;
  this.state.messages.push(message);
});
```

**3. Enviar desde cliente (Frontend):**

```typescript
// Game.ts - dentro de create()
this.input.keyboard.on("keydown-ENTER", () => {
  const text = prompt("Escribe tu mensaje:");
  if (text) {
    this.room.send("chat", { text });
  }
});
```

### Ejemplo 2: Sistema de Salud

**1. A√±adir al jugador:**

```typescript
// MyRoomState.ts
export class Player extends Schema {
  // ... c√≥digo existente ...
  @type("number") health: number = 100;
}
```

**2. Mostrar en cliente:**

```typescript
// Game.ts - dentro de create()
$(this.room.state).players.onAdd((player, sessionId) => {
  const entity = this.physics.add.image(player.x, player.y, player.shipType);

  // Crear barra de salud
  const healthBar = this.add.rectangle(
    player.x,
    player.y - 20,
    50,
    5,
    0x00ff00
  );

  $(player).onChange(() => {
    // Actualizar barra seg√∫n salud actual
    healthBar.width = (player.health / 100) * 50;
    healthBar.fillColor = player.health > 50 ? 0x00ff00 : 0xff0000;
  });
});
```

## üéÆ Funcionalidades Implementadas en el Proyecto

### üè∑Ô∏è Sistema de Usernames

Cada jugador puede personalizar su nombre al entrar al juego:

#### En el Servidor (`MyRoomState.ts`):

```typescript
export class Player extends Schema {
  @type("number") x: number;
  @type("number") y: number;
  @type("number") tick: number;
  @type("string") username: string = "Player"; // üÜï Username del jugador
  @type("string") shipType: string = "ship_0001"; // üÜï Tipo de nave
  inputQueue: InputData[] = [];
}
```

#### En el Cliente (`Game.ts`):

```typescript
async connect() {
  // Solicitar username al usuario
  let username = prompt("¬°Bienvenido al juego!\n\nIngresa tu nombre de usuario:");

  // Validar y limpiar username
  if (!username || username.trim() === "") {
    username = `Player_${Math.floor(Math.random() * 1000)}`;
  }
  username = username.trim().substring(0, 12); // M√°ximo 12 caracteres

  // Enviar username al servidor
  this.room = await client.joinOrCreate("my_room", { username });
}
```

### üöÄ Sistema de Naves Aleatorias

Cada jugador recibe una nave √∫nica aleatoriamente seleccionada:

#### Pool de Naves Disponibles:

```typescript
// MyRoom.ts - 23 naves diferentes
const shipTypes = [
  "ship_0001",
  "ship_0002",
  "ship_0003",
  "ship_0004",
  "ship_0005",
  "ship_0006",
  "ship_0007",
  "ship_0008",
  "ship_0009",
  "ship_0010",
  "ship_0011",
  "ship_0012",
  "ship_0013",
  "ship_0014",
  "ship_0015",
  "ship_0016",
  "ship_0017",
  "ship_0018",
  "ship_0019",
  "ship_0020",
  "ship_0021",
  "ship_0022",
  "ship_0023",
];

// Selecci√≥n aleatoria
player.shipType = shipTypes[Math.floor(Math.random() * shipTypes.length)];
```

#### Carga de Assets (`Preloader.ts`):

```typescript
preload() {
  // Cargar todas las naves disponibles autom√°ticamente
  for (let i = 1; i <= 23; i++) {
    const shipNumber = i.toString().padStart(4, '0');
    this.load.image(`ship_${shipNumber}`, `ship_${shipNumber}.png`);
  }
}
```

### üìù Visualizaci√≥n de Usernames

Los nombres aparecen flotando arriba de cada nave:

```typescript
// Game.ts - Crear username text
$(this.room.state).players.onAdd((player, sessionId) => {
  // Crear sprite con la nave espec√≠fica
  const entity = this.physics.add.image(player.x, player.y, player.shipType);

  // Crear texto del username arriba del jugador
  const usernameText = this.add
    .text(player.x, player.y - 30, player.username, {
      fontSize: "12px",
      color: "#ffffff",
      stroke: "#000000",
      strokeThickness: 2,
      align: "center",
    })
    .setOrigin(0.5);

  this.playerUsernames[sessionId] = usernameText;
});
```

### üîÑ Sincronizaci√≥n de Posiciones

Los usernames siguen a los jugadores autom√°ticamente:

```typescript
// Game.ts - En fixedTick()
for (let sessionId in this.playerEntities) {
  const entity = this.playerEntities[sessionId];
  const usernameText = this.playerUsernames[sessionId];

  // Interpolar posici√≥n de nave
  entity.x = Phaser.Math.Linear(entity.x, serverX, 0.2);
  entity.y = Phaser.Math.Linear(entity.y, serverY, 0.2);

  // Mover username siguiendo a la nave
  if (usernameText) {
    usernameText.x = entity.x;
    usernameText.y = entity.y - 30; // 30 p√≠xeles arriba de la nave
  }
}
```

### üé® Estilos del Username

- **Color:** Blanco (`#ffffff`)
- **Borde:** Negro con grosor de 2px para mejor legibilidad
- **Tama√±o:** 12px
- **Posici√≥n:** 30 p√≠xeles arriba de la nave
- **Alineaci√≥n:** Centrado
- **L√≠mite:** M√°ximo 12 caracteres

### üéÆ Sistema de Controles Duales

Los jugadores pueden usar dos sistemas de control diferentes para mayor comodidad:

#### Controles Implementados:

```typescript
// Game.ts - Configuraci√≥n de controles
async create() {
  // Controles con flechas del teclado (tradicional)
  this.cursorKeys = this.input!.keyboard!.createCursorKeys();

  // Controles WASD (para gamers de PC)
  this.wasdKeys = {
    W: this.input!.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.W),
    A: this.input!.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.A),
    S: this.input!.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.S),
    D: this.input!.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.D),
  };
}
```

#### L√≥gica de Input Combinada:

```typescript
// Game.ts - En fixedTick()
fixedTick() {
  // Combinar ambos sistemas de control con OR l√≥gico
  this.inputPayload.left = this.cursorKeys.left.isDown || this.wasdKeys.A.isDown;
  this.inputPayload.right = this.cursorKeys.right.isDown || this.wasdKeys.D.isDown;
  this.inputPayload.up = this.cursorKeys.up.isDown || this.wasdKeys.W.isDown;
  this.inputPayload.down = this.cursorKeys.down.isDown || this.wasdKeys.S.isDown;

  // El resto de la l√≥gica permanece igual
  this.room.send(0, this.inputPayload);
}
```

#### Mapeo de Controles:

| Acci√≥n        | Flechas | WASD |
| ------------- | ------- | ---- |
| **Arriba**    | ‚Üë       | W    |
| **Abajo**     | ‚Üì       | S    |
| **Izquierda** | ‚Üê       | A    |
| **Derecha**   | ‚Üí       | D    |

#### Ventajas del Sistema Dual:

- ‚úÖ **Flexibilidad:** Los jugadores eligen su preferencia
- ‚úÖ **Accesibilidad:** Funciona para diferentes tipos de teclados
- ‚úÖ **Familiaridad:** WASD es est√°ndar en juegos de PC
- ‚úÖ **Sin conflictos:** Ambos sistemas pueden usarse simult√°neamente

### üèüÔ∏è Sistema de Sala Masiva

El servidor ahora soporta hasta **100 jugadores simult√°neos**:

```typescript
// MyRoom.ts - Configuraci√≥n del servidor
export class MyRoom extends Room<MyRoomState> {
  maxClients = 100; // ‚¨ÜÔ∏è Aumentado de 4 a 100 jugadores

  // El resto de la l√≥gica escala autom√°ticamente
  // Colyseus maneja eficientemente la sincronizaci√≥n
}
```

#### Beneficios de 100 Jugadores:

- üéä **Experiencia masiva:** Batallas √©picas y eventos grandes
- ‚ö° **Eficiencia:** Colyseus optimiza autom√°ticamente la red
- üîß **Escalabilidad:** F√°cil ajustar seg√∫n necesidades del servidor
- üéØ **Testing:** Ideal para pruebas de carga y stress testing

## üìÅ Estructura de Archivos Explicada

```
fullstack-rpg/
‚îú‚îÄ‚îÄ frontend/                          # üéÆ CLIENTE (Phaser 3)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.ts                   # üöÄ Punto de entrada, inicia el juego
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ game/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ root.ts               # ‚öôÔ∏è Configuraci√≥n principal de Phaser
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ scenes/               # üé¨ Todas las escenas del juego
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ Boot.ts           # üîß Carga recursos b√°sicos
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ Preloader.ts      # ‚è≥ Carga assets + barra progreso
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ MainMenu.ts       # üìã Men√∫ principal
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ Game.ts           # üéØ Juego multijugador principal
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ GameOver.ts       # üíÄ Pantalla de fin de juego
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/                   # üñºÔ∏è Im√°genes, sonidos, etc.
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ style.css                 # üé® Estilos CSS
‚îÇ   ‚îú‚îÄ‚îÄ index.html                    # üåê HTML principal
‚îÇ   ‚îú‚îÄ‚îÄ package.json                  # üì¶ Dependencias del frontend
‚îÇ   ‚îî‚îÄ‚îÄ vite/                         # ‚ö° Configuraci√≥n Vite (bundler)
‚îú‚îÄ‚îÄ backend/                          # üñ•Ô∏è SERVIDOR (Colyseus)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts                  # üöÄ Punto de entrada del servidor
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.config.ts             # ‚öôÔ∏è Configuraci√≥n servidor y rutas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rooms/                    # üè† L√≥gica de salas multijugador
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MyRoom.ts             # üß† Sala principal, l√≥gica del juego
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ schema/               # üìã Definici√≥n de estados
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ MyRoomState.ts    # üîÑ Estado sincronizado jugadores
‚îÇ   ‚îú‚îÄ‚îÄ package.json                  # üì¶ Dependencias del backend
‚îÇ   ‚îî‚îÄ‚îÄ loadtest/                     # üß™ Pruebas de carga
‚îî‚îÄ‚îÄ README.md                         # üìñ Esta documentaci√≥n
```

## üîß Comandos de Desarrollo

### Frontend

```bash
npm run dev          # üöÄ Servidor desarrollo (localhost:8080)
npm run build        # üì¶ Compilar para producci√≥n
```

### Backend

```bash
npm run dev          # üöÄ Servidor desarrollo con recarga autom√°tica
npm run build        # üì¶ Compilar TypeScript
npm run loadtest     # üß™ Prueba con 2 clientes simulados
```

### URLs √ötiles

- **Juego:** http://localhost:8080
- **Monitor Colyseus:** http://localhost:2567/monitor
- **Playground:** http://localhost:2567

## üêõ Debugging y Resoluci√≥n de Problemas

### Problema: "No se puede conectar al servidor"

```javascript
// Revisar en Game.ts que la URL sea correcta
const BACKEND_URL = "ws://localhost:2567"; // ‚úÖ Debe coincidir con puerto backend
```

### Problema: "Los jugadores no se mueven suavemente"

```typescript
// Ajustar velocidad de interpolaci√≥n en Game.ts
entity.x = Phaser.Math.Linear(entity.x, serverX, 0.1); // üêå M√°s suave
entity.x = Phaser.Math.Linear(entity.x, serverX, 0.5); // üèÉ‚Äç‚ôÇÔ∏è M√°s r√°pido
```

### Problema: "FPS bajos"

```typescript
// En root.ts, ajustar configuraci√≥n de rendimiento
const config = {
  // ... otras opciones ...
  render: {
    pixelArt: true, // ‚úÖ Mejor rendimiento para pixel art
    antialias: false, // ‚úÖ Desactivar antialiasing
    roundPixels: true, // ‚úÖ Redondear p√≠xeles
  },
};
```

## üöÄ Pr√≥ximos Pasos para Aprender M√°s

### Nivel B√°sico

1. **A√±adir m√°s sprites:** Cambiar nave por otros personajes
2. **Animaciones:** Crear animaciones de caminar para jugadores
3. **Sonidos:** Agregar efectos de sonido y m√∫sica
4. **UI:** Crear interfaz con botones y men√∫s

### Nivel Intermedio

1. **Sistema de chat:** Comunicaci√≥n entre jugadores
2. **Diferentes salas:** M√∫ltiples niveles o mapas
3. **F√≠sica avanzada:** Colisiones con obst√°culos
4. **Sistema de inventario:** Items y equipamiento

### Nivel Avanzado

1. **Base de datos:** Guardar progreso de jugadores
2. **Autenticaci√≥n:** Sistema de login y usuarios
3. **Balanceador de carga:** M√∫ltiples servidores
4. **Modo producci√≥n:** Despliegue en la nube

## üìö Recursos para Seguir Aprendiendo

### Documentaci√≥n Oficial

- üìñ [Phaser 3 Docs](https://photonstorm.github.io/phaser3-docs/)
- üìñ [Colyseus Docs](https://docs.colyseus.io/)

### Tutoriales Recomendados

- üé• [Phaser 3 Examples](https://phaser.io/examples) - Cientos de ejemplos
- üé• [Colyseus Examples](https://github.com/colyseus/colyseus-examples) - Proyectos de ejemplo

### Comunidades

- üí¨ [Phaser Discord](https://discord.gg/phaser)
- üí¨ [Colyseus Discord](https://discord.gg/RY8rRS7)
- üê¶ [Twitter - @photonstorm](https://twitter.com/photonstorm)

## ü§ù Contribuir al Proyecto

1. Haz fork del repositorio
2. Crea una rama: `git checkout -b mi-nueva-funcionalidad`
3. Haz tus cambios y committea: `git commit -am 'Agregu√© nueva funcionalidad'`
4. Push: `git push origin mi-nueva-funcionalidad`
5. Crea un Pull Request

---

### üí° Tips Finales para Principiantes

1. **Empieza peque√±o:** Modifica valores como velocidad o colores antes de a√±adir funcionalidades
2. **Usa console.log():** Imprime valores para entender qu√© est√° pasando
3. **Experimenta:** Cambia n√∫meros, colores y textos para ver qu√© sucede
4. **Lee errores:** Los mensajes de error te dicen exactamente qu√© est√° mal
5. **Pregunta:** Las comunidades de gamedev son muy colaborativas

¬°Divi√©rtete creando tu primer juego multijugador! üéÆ‚ú®
