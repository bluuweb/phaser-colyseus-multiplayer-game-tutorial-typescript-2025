# üéÆ Fullstack RPG - Tutorial Completo para Principiantes

Un proyecto de juego multijugador en tiempo real desarrollado con **Phaser 3** (cliente) y **Colyseus** (servidor). Este proyecto te permitir√° aprender los fundamentos del desarrollo de juegos web y sistemas multijugador.

## üìñ ¬øQu√© es este proyecto?

Este es un **juego RPG multijugador** donde los jugadores pueden moverse en tiempo real y ver a otros jugadores conectados. Implementa:

- ‚úÖ **Sistema de escenas** con flujo de juego completo
- ‚úÖ **Multijugador en tiempo real** con sincronizaci√≥n de estados
- ‚úÖ **Predicci√≥n del lado del cliente** para movimiento fluido
- ‚úÖ **Interpolaci√≥n** de posiciones de otros jugadores
- ‚úÖ **Sistema de ticks fijos** para consistencia en el servidor

## üöÄ Instalaci√≥n R√°pida

### Prerrequisitos

- Node.js 16+ instalado
- Un editor de c√≥digo (VS Code recomendado)

### Configuraci√≥n del Proyecto

1. **Clona o descarga el proyecto**
2. **Instalar dependencias del backend:**

   ```bash
   cd backend
   npm install
   ```

3. **Instalar dependencias del frontend:**
   ```bash
   cd ../frontend
   npm install
   ```

### Ejecutar el Proyecto

1. **Iniciar el servidor (backend):**

   ```bash
   cd backend
   npm run dev
   ```

   ‚úÖ El servidor estar√° en `http://localhost:2567`

2. **Iniciar el cliente (frontend):**

   ```bash
   cd frontend
   npm run dev
   ```

   ‚úÖ El juego estar√° en `http://localhost:8080`

3. **¬°Jugar!**
   - Abre m√∫ltiples pesta√±as del navegador para ver el multijugador
   - Usa las flechas del teclado para moverte

## üéØ ¬øQu√© es Phaser 3?

**Phaser** es un framework de JavaScript para crear juegos 2D que funcionan en navegadores web. Es como el "motor" que maneja gr√°ficos, sonido, f√≠sica y entrada del usuario.

### Conceptos Fundamentales de Phaser

#### 1. El Game Object (Objeto Juego)

```typescript
// frontend/src/game/root.ts - Configuraci√≥n principal
const config: Phaser.Types.Core.GameConfig = {
  type: AUTO, // Usa WebGL o Canvas autom√°ticamente
  width: 800, // Ancho del juego en p√≠xeles
  height: 600, // Alto del juego en p√≠xeles
  parent: "game-container", // Elemento HTML donde se renderiza
  backgroundColor: "#028af8", // Color de fondo
  physics: {
    default: "arcade", // Sistema de f√≠sica arcade (simple)
  },
  pixelArt: true, // Optimizado para gr√°ficos pixelados
  scene: [Boot, Preloader, MainMenu, MainGame, GameOver], // Lista de escenas
};
```

#### 2. Escenas (Scenes) - Los "Estados" del Juego

Las escenas son como diferentes pantallas o estados de tu juego:

##### üîß Boot Scene (`frontend/src/game/scenes/Boot.ts`)

**Prop√≥sito:** Primera escena que se ejecuta, carga recursos m√≠nimos

```typescript
export class Boot extends Scene {
  preload() {
    // Carga solo recursos esenciales (fondos, logos)
    this.load.image("background", "assets/bg.png");
  }

  create() {
    // Inmediatamente cambia a Preloader
    this.scene.start("Preloader");
  }
}
```

##### ‚è≥ Preloader Scene (`frontend/src/game/scenes/Preloader.ts`)

**Prop√≥sito:** Muestra progreso de carga y carga todos los assets del juego

```typescript
export class Preloader extends Scene {
  init() {
    // Muestra fondo y crea barra de progreso visual
    this.add.image(512, 384, "background");
    const bar = this.add.rectangle(512 - 230, 384, 4, 28, 0xffffff);

    // Actualiza barra cuando cargan assets
    this.load.on("progress", (progress: number) => {
      bar.width = 4 + 460 * progress;
    });
  }

  preload() {
    // Carga todos los assets del juego
    this.load.image("logo", "logo.png");
    this.load.image("ship_0001", "ship_0001.png");
  }
}
```

##### üéÆ Main Menu Scene (`frontend/src/game/scenes/MainMenu.ts`)

**Prop√≥sito:** Men√∫ principal con logo y texto

```typescript
export class MainMenu extends Scene {
  create() {
    // Muestra logo y t√≠tulo
    this.add.image(512, 300, "logo");
    this.add
      .text(512, 460, "Main Menu", {
        fontFamily: "Arial Black",
        fontSize: 38,
        color: "#ffffff",
      })
      .setOrigin(0.5);

    // Al hacer clic, inicia el juego
    this.input.once("pointerdown", () => {
      this.scene.start("Game");
    });
  }
}
```

##### üéØ Game Scene (`frontend/src/game/scenes/Game.ts`) - ¬°El Coraz√≥n!

**Prop√≥sito:** Escena principal donde ocurre toda la jugabilidad multijugador

**M√©todos Principales:**

```typescript
export class Game extends Scene {
  async create() {
    // 1. Configurar controles
    this.cursorKeys = this.input.keyboard.createCursorKeys();

    // 2. Conectar al servidor Colyseus
    await this.connect();

    // 3. Configurar callbacks para jugadores
    this.room.state.players.onAdd((player, sessionId) => {
      // Crear sprite cuando un jugador se une
      const entity = this.physics.add.image(player.x, player.y, "ship_0001");
      this.playerEntities[sessionId] = entity;
    });
  }

  update(time: number, delta: number) {
    // Se ejecuta cada frame (60 veces por segundo)
    // Maneja el loop de juego con tiempo fijo
    this.elapsedTime += delta;
    while (this.elapsedTime >= this.fixedTimeStep) {
      this.elapsedTime -= this.fixedTimeStep;
      this.fixedTick(time, this.fixedTimeStep);
    }
  }

  fixedTick() {
    // Procesa entrada del usuario
    // Mueve jugador localmente (predicci√≥n)
    // Env√≠a input al servidor
    // Interpola otros jugadores
  }
}
```

## üåê ¬øQu√© es Colyseus?

**Colyseus** es un framework de servidor para crear juegos multijugador en tiempo real. Maneja la comunicaci√≥n entre m√∫ltiples clientes y sincroniza el estado del juego.

### Arquitectura del Servidor

#### 1. Punto de Entrada (`backend/src/index.ts`)

```typescript
// Importa configuraci√≥n y inicia servidor
import { listen } from "@colyseus/tools";
import app from "./app.config";

listen(app); // Escucha en puerto 2567
```

#### 2. Configuraci√≥n del Servidor (`backend/src/app.config.ts`)

```typescript
export default config({
  initializeGameServer: (gameServer) => {
    // Registra tipos de salas disponibles
    gameServer.define("my_room", MyRoom);
  },

  initializeExpress: (app) => {
    // Configura rutas HTTP adicionales
    app.get("/hello_world", (req, res) => {
      res.send("It's time to kick ass and chew bubblegum!");
    });

    // Panel de monitoreo en /monitor
    app.use("/monitor", monitor());
  },
});
```

#### 3. La Sala de Juego (`backend/src/rooms/MyRoom.ts`) - ¬°El Cerebro!

Una **Room** es donde ocurre toda la l√≥gica del juego multijugador:

```typescript
export class MyRoom extends Room<MyRoomState> {
  maxClients = 4; // M√°ximo 4 jugadores por sala
  fixedTimeStep = 1000 / 60; // 60 ticks por segundo

  onCreate(options: any) {
    // Configuraci√≥n inicial
    this.state.mapWidth = 800;
    this.state.mapHeight = 600;

    // Escucha mensajes del cliente (mensaje tipo 0 = movimiento)
    this.onMessage(0, (client, input) => {
      const player = this.state.players.get(client.sessionId);
      player.inputQueue.push(input); // Agrega a cola de entrada
    });

    // Simulaci√≥n de servidor a ticks fijos
    this.setSimulationInterval((deltaTime) => {
      // Procesa todos los inputs pendientes
      this.fixedTick(this.fixedTimeStep);
    });
  }

  fixedTick(timeStep: number) {
    const velocity = 2;

    this.state.players.forEach((player) => {
      let input: InputData;

      // Procesa todos los inputs en cola
      while ((input = player.inputQueue.shift())) {
        if (input.left) player.x -= velocity;
        if (input.right) player.x += velocity;
        if (input.up) player.y -= velocity;
        if (input.down) player.y += velocity;

        player.tick = input.tick; // Sincroniza tick
      }
    });
  }

  onJoin(client: Client, options: any) {
    // Se ejecuta cuando un jugador se conecta
    const player = new Player();
    player.x = Math.random() * this.state.mapWidth; // Posici√≥n aleatoria
    player.y = Math.random() * this.state.mapHeight;

    this.state.players.set(client.sessionId, player);
  }

  onLeave(client: Client, consented: boolean) {
    // Se ejecuta cuando un jugador se desconecta
    this.state.players.delete(client.sessionId);
  }
}
```

#### 4. Estado del Juego (`backend/src/rooms/schema/MyRoomState.ts`)

El **Estado** es lo que se sincroniza entre servidor y todos los clientes:

```typescript
export class Player extends Schema {
  @type("number") x: number; // Posici√≥n X
  @type("number") y: number; // Posici√≥n Y
  @type("number") tick: number; // Tick actual para sincronizaci√≥n
  inputQueue: InputData[] = []; // Cola de inputs (no se sincroniza)
}

export class MyRoomState extends Schema {
  @type("number") mapWidth: number; // Ancho del mapa
  @type("number") mapHeight: number; // Alto del mapa
  @type({ map: Player }) players = new MapSchema<Player>(); // Todos los jugadores
}

export interface InputData {
  left: boolean; // ¬øPresionando izquierda?
  right: boolean; // ¬øPresionando derecha?
  up: boolean; // ¬øPresionando arriba?
  down: boolean; // ¬øPresionando abajo?
  tick: number; // Tick del cliente cuando envi√≥ input
}
```

## üîÑ Flujo de Comunicaci√≥n Cliente-Servidor

### 1. **Inicializaci√≥n**

```mermaid
Cliente ‚Üí Servidor: Conectar a ws://localhost:2567
Cliente ‚Üí Servidor: Unirse a sala "my_room"
Servidor ‚Üí Cliente: Env√≠a estado inicial (otros jugadores)
```

### 2. **Loop de Juego (cada frame)**

```mermaid
Cliente: Lee teclas presionadas
Cliente: Mueve jugador localmente (PREDICCI√ìN)
Cliente ‚Üí Servidor: Env√≠a input {left: true, tick: 1234}
Servidor: Procesa input, actualiza posici√≥n oficial
Servidor ‚Üí Todos: Sincroniza nuevo estado
Cliente: Compara posici√≥n local vs servidor (RECONCILIACI√ìN)
```

### 3. **Otros Jugadores**

```mermaid
Servidor ‚Üí Cliente: Estado de otros jugadores actualizado
Cliente: INTERPOLA posiciones suavemente
Cliente: Renderiza frame con todos los jugadores
```

## üõ†Ô∏è T√©cnicas Avanzadas Implementadas

### 1. **Predicci√≥n del Lado del Cliente**

```typescript
// En Game.ts - fixedTick()
// El cliente mueve al jugador INMEDIATAMENTE
if (this.inputPayload.left) {
  this.currentPlayer.x -= velocity; // ‚ö° Respuesta inmediata
}
// Luego env√≠a el input al servidor
this.room.send(0, this.inputPayload);
```

### 2. **Interpolaci√≥n de Otros Jugadores**

```typescript
// En Game.ts - fixedTick()
for (let sessionId in this.playerEntities) {
  if (sessionId === this.room.sessionId) continue; // Saltar jugador local

  const entity = this.playerEntities[sessionId];
  const { serverX, serverY } = entity.data.values;

  // Mueve suavemente hacia la posici√≥n del servidor
  entity.x = Phaser.Math.Linear(entity.x, serverX, 0.2); // üåä Interpolaci√≥n suave
  entity.y = Phaser.Math.Linear(entity.y, serverY, 0.2);
}
```

### 3. **Sistema de Ticks Fijos**

```typescript
// Tanto cliente como servidor usan tiempo fijo
const fixedTimeStep = 1000 / 60; // 60 FPS

update(time: number, delta: number) {
  this.elapsedTime += delta;
  while (this.elapsedTime >= this.fixedTimeStep) {
    this.elapsedTime -= this.fixedTimeStep;
    this.fixedTick(); // ‚è∞ L√≥gica a tiempo fijo
  }
}
```

## üéì Tutorial: Crear tu Primera Funci√≥n

### Ejemplo 1: Agregar Sistema de Chat

**1. A√±adir al estado (Backend):**

```typescript
// MyRoomState.ts
export class ChatMessage extends Schema {
  @type("string") text: string;
  @type("string") author: string;
}

export class MyRoomState extends Schema {
  // ... c√≥digo existente ...
  @type([ChatMessage]) messages = new ArraySchema<ChatMessage>();
}
```

**2. Manejar mensajes (Backend):**

```typescript
// MyRoom.ts - dentro de onCreate()
this.onMessage("chat", (client, data) => {
  const message = new ChatMessage();
  message.text = data.text;
  message.author = client.sessionId;
  this.state.messages.push(message);
});
```

**3. Enviar desde cliente (Frontend):**

```typescript
// Game.ts - dentro de create()
this.input.keyboard.on("keydown-ENTER", () => {
  const text = prompt("Escribe tu mensaje:");
  if (text) {
    this.room.send("chat", { text });
  }
});
```

### Ejemplo 2: Sistema de Salud

**1. A√±adir al jugador:**

```typescript
// MyRoomState.ts
export class Player extends Schema {
  // ... c√≥digo existente ...
  @type("number") health: number = 100;
}
```

**2. Mostrar en cliente:**

```typescript
// Game.ts - dentro de create()
$(this.room.state).players.onAdd((player, sessionId) => {
  const entity = this.physics.add.image(player.x, player.y, "ship_0001");

  // Crear barra de salud
  const healthBar = this.add.rectangle(
    player.x,
    player.y - 20,
    50,
    5,
    0x00ff00
  );

  $(player).onChange(() => {
    // Actualizar barra seg√∫n salud actual
    healthBar.width = (player.health / 100) * 50;
    healthBar.fillColor = player.health > 50 ? 0x00ff00 : 0xff0000;
  });
});
```

## üìÅ Estructura de Archivos Explicada

```
fullstack-rpg/
‚îú‚îÄ‚îÄ frontend/                          # üéÆ CLIENTE (Phaser 3)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.ts                   # üöÄ Punto de entrada, inicia el juego
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ game/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ root.ts               # ‚öôÔ∏è Configuraci√≥n principal de Phaser
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ scenes/               # üé¨ Todas las escenas del juego
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ Boot.ts           # üîß Carga recursos b√°sicos
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ Preloader.ts      # ‚è≥ Carga assets + barra progreso
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ MainMenu.ts       # üìã Men√∫ principal
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ Game.ts           # üéØ Juego multijugador principal
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ GameOver.ts       # üíÄ Pantalla de fin de juego
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/                   # üñºÔ∏è Im√°genes, sonidos, etc.
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ style.css                 # üé® Estilos CSS
‚îÇ   ‚îú‚îÄ‚îÄ index.html                    # üåê HTML principal
‚îÇ   ‚îú‚îÄ‚îÄ package.json                  # üì¶ Dependencias del frontend
‚îÇ   ‚îî‚îÄ‚îÄ vite/                         # ‚ö° Configuraci√≥n Vite (bundler)
‚îú‚îÄ‚îÄ backend/                          # üñ•Ô∏è SERVIDOR (Colyseus)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts                  # üöÄ Punto de entrada del servidor
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.config.ts             # ‚öôÔ∏è Configuraci√≥n servidor y rutas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rooms/                    # üè† L√≥gica de salas multijugador
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MyRoom.ts             # üß† Sala principal, l√≥gica del juego
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ schema/               # üìã Definici√≥n de estados
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ MyRoomState.ts    # üîÑ Estado sincronizado jugadores
‚îÇ   ‚îú‚îÄ‚îÄ package.json                  # üì¶ Dependencias del backend
‚îÇ   ‚îî‚îÄ‚îÄ loadtest/                     # üß™ Pruebas de carga
‚îî‚îÄ‚îÄ README.md                         # üìñ Esta documentaci√≥n
```

## üîß Comandos de Desarrollo

### Frontend

```bash
npm run dev          # üöÄ Servidor desarrollo (localhost:8080)
npm run build        # üì¶ Compilar para producci√≥n
```

### Backend

```bash
npm run dev          # üöÄ Servidor desarrollo con recarga autom√°tica
npm run build        # üì¶ Compilar TypeScript
npm run loadtest     # üß™ Prueba con 2 clientes simulados
```

### URLs √ötiles

- **Juego:** http://localhost:8080
- **Monitor Colyseus:** http://localhost:2567/monitor
- **Playground:** http://localhost:2567

## üêõ Debugging y Resoluci√≥n de Problemas

### Problema: "No se puede conectar al servidor"

```javascript
// Revisar en Game.ts que la URL sea correcta
const BACKEND_URL = "ws://localhost:2567"; // ‚úÖ Debe coincidir con puerto backend
```

### Problema: "Los jugadores no se mueven suavemente"

```typescript
// Ajustar velocidad de interpolaci√≥n en Game.ts
entity.x = Phaser.Math.Linear(entity.x, serverX, 0.1); // üêå M√°s suave
entity.x = Phaser.Math.Linear(entity.x, serverX, 0.5); // üèÉ‚Äç‚ôÇÔ∏è M√°s r√°pido
```

### Problema: "FPS bajos"

```typescript
// En root.ts, ajustar configuraci√≥n de rendimiento
const config = {
  // ... otras opciones ...
  render: {
    pixelArt: true, // ‚úÖ Mejor rendimiento para pixel art
    antialias: false, // ‚úÖ Desactivar antialiasing
    roundPixels: true, // ‚úÖ Redondear p√≠xeles
  },
};
```

## üöÄ Pr√≥ximos Pasos para Aprender M√°s

### Nivel B√°sico

1. **A√±adir m√°s sprites:** Cambiar nave por otros personajes
2. **Animaciones:** Crear animaciones de caminar para jugadores
3. **Sonidos:** Agregar efectos de sonido y m√∫sica
4. **UI:** Crear interfaz con botones y men√∫s

### Nivel Intermedio

1. **Sistema de chat:** Comunicaci√≥n entre jugadores
2. **Diferentes salas:** M√∫ltiples niveles o mapas
3. **F√≠sica avanzada:** Colisiones con obst√°culos
4. **Sistema de inventario:** Items y equipamiento

### Nivel Avanzado

1. **Base de datos:** Guardar progreso de jugadores
2. **Autenticaci√≥n:** Sistema de login y usuarios
3. **Balanceador de carga:** M√∫ltiples servidores
4. **Modo producci√≥n:** Despliegue en la nube

## üìö Recursos para Seguir Aprendiendo

### Documentaci√≥n Oficial

- üìñ [Phaser 3 Docs](https://photonstorm.github.io/phaser3-docs/)
- üìñ [Colyseus Docs](https://docs.colyseus.io/)

### Tutoriales Recomendados

- üé• [Phaser 3 Examples](https://phaser.io/examples) - Cientos de ejemplos
- üé• [Colyseus Examples](https://github.com/colyseus/colyseus-examples) - Proyectos de ejemplo

### Comunidades

- üí¨ [Phaser Discord](https://discord.gg/phaser)
- üí¨ [Colyseus Discord](https://discord.gg/RY8rRS7)
- üê¶ [Twitter - @photonstorm](https://twitter.com/photonstorm)

## ü§ù Contribuir al Proyecto

1. Haz fork del repositorio
2. Crea una rama: `git checkout -b mi-nueva-funcionalidad`
3. Haz tus cambios y committea: `git commit -am 'Agregu√© nueva funcionalidad'`
4. Push: `git push origin mi-nueva-funcionalidad`
5. Crea un Pull Request

---

### üí° Tips Finales para Principiantes

1. **Empieza peque√±o:** Modifica valores como velocidad o colores antes de a√±adir funcionalidades
2. **Usa console.log():** Imprime valores para entender qu√© est√° pasando
3. **Experimenta:** Cambia n√∫meros, colores y textos para ver qu√© sucede
4. **Lee errores:** Los mensajes de error te dicen exactamente qu√© est√° mal
5. **Pregunta:** Las comunidades de gamedev son muy colaborativas

¬°Divi√©rtete creando tu primer juego multijugador! üéÆ‚ú®
